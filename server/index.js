import express from 'express';
import cors from 'cors';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { Pool } from 'pg';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 5174;
const JWT_SECRET = process.env.ADMIN_JWT_SECRET || 'dev-secret-change-me';
const DATABASE_URL = process.env.DATABASE_URL;
const USE_SSL =
  process.env.PGSSLMODE === 'require' ||
  process.env.PGSSL === 'true' ||
  process.env.DATABASE_SSL === 'true';

const pool = new Pool({
  connectionString: DATABASE_URL,
  ssl: USE_SSL ? { rejectUnauthorized: false } : undefined,
});

app.use(cors());
app.use(express.json());

const initDatabase = async () => {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS admin_users (
      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      email TEXT UNIQUE NOT NULL,
      password_hash TEXT NOT NULL,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS guest_families (
      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      family_name TEXT NOT NULL,
      access_code TEXT UNIQUE NOT NULL,
      phone TEXT,
      notes TEXT,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS family_members (
      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      family_id INTEGER NOT NULL REFERENCES guest_families(id) ON DELETE CASCADE,
      name TEXT NOT NULL,
      relationship TEXT,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );

    CREATE TABLE IF NOT EXISTS member_confirmations (
      id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      member_id INTEGER NOT NULL REFERENCES family_members(id) ON DELETE CASCADE,
      attending BOOLEAN NOT NULL,
      dietary_restrictions TEXT,
      message TEXT,
      confirmed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );
  `);
};

const withTransaction = async (fn) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    const result = await fn(client);
    await client.query('COMMIT');
    return result;
  } catch (err) {
    await client.query('ROLLBACK');
    throw err;
  } finally {
    client.release();
  }
};

const generateAccessCode = () => {
  let code = '';
  for (let i = 0; i < 8; i += 1) {
    code += Math.floor(Math.random() * 10).toString();
  }
  return code;
};

const issueToken = (email) =>
  jwt.sign({ email }, JWT_SECRET, { expiresIn: '7d' });

const authMiddleware = (req, res, next) => {
  const authHeader = req.headers.authorization || '';
  const token = authHeader.startsWith('Bearer ')
    ? authHeader.slice(7)
    : null;

  if (!token) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = payload;
    return next();
  } catch (err) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
};

const start = async () => {
  await initDatabase();

  app.get('/api/health', (_req, res) => {
    res.json({ ok: true });
  });

  app.post('/api/admin/login', async (req, res) => {
    const { email, password } = req.body || {};
    if (!email || !password) {
      return res.status(400).json({ error: 'Email e senha são obrigatórios.' });
    }

    const { rows } = await pool.query('SELECT * FROM admin_users WHERE email = $1', [
      email,
    ]);
    const user = rows[0];

    if (!user || !bcrypt.compareSync(password, user.password_hash)) {
      return res.status(401).json({ error: 'Login inválido.' });
    }

    return res.json({ token: issueToken(user.email), email: user.email });
  });

  app.get('/api/admin/session', authMiddleware, (req, res) => {
    res.json({ email: req.user.email });
  });

  app.get('/api/admin/families', authMiddleware, async (_req, res) => {
    const families = await pool.query('SELECT * FROM guest_families ORDER BY created_at DESC');
    const members = await pool.query('SELECT * FROM family_members ORDER BY created_at ASC');
    const confirmations = await pool.query(
      'SELECT * FROM member_confirmations ORDER BY confirmed_at DESC, id DESC'
    );

    res.json({
      families: families.rows,
      members: members.rows,
      confirmations: confirmations.rows,
    });
  });

  app.post('/api/admin/families', authMiddleware, async (req, res) => {
    const { family_name, phone, notes, members } = req.body || {};

    if (!family_name || !Array.isArray(members) || members.length === 0) {
      return res.status(400).json({ error: 'Nome da família e membros são obrigatórios.' });
    }

    let accessCode = generateAccessCode();

    for (let attempt = 0; attempt < 5; attempt += 1) {
      try {
        const result = await withTransaction(async (client) => {
          const insertFamily = await client.query(
            'INSERT INTO guest_families (family_name, access_code, phone, notes) VALUES ($1, $2, $3, $4) RETURNING *',
            [family_name.trim(), accessCode, phone?.trim() || null, notes?.trim() || null]
          );
          const family = insertFamily.rows[0];

          await Promise.all(
            members.map((member) =>
              client.query(
                'INSERT INTO family_members (family_id, name, relationship) VALUES ($1, $2, $3)',
                [family.id, member.name.trim(), member.relationship?.trim() || null]
              )
            )
          );

          const familyMembers = await client.query(
            'SELECT * FROM family_members WHERE family_id = $1 ORDER BY created_at ASC',
            [family.id]
          );

          return { family, members: familyMembers.rows };
        });

        return res.json(result);
      } catch (err) {
        if (String(err.message || '').includes('duplicate key') || String(err.message || '').includes('unique')) {
          accessCode = generateAccessCode();
        } else {
          console.error('Error:', err);
          return res.status(500).json({ error: 'Erro ao salvar família.' });
        }
      }
    }

    return res.status(500).json({ error: 'Não foi possível gerar código único.' });
  });

  app.put('/api/admin/families/:id', authMiddleware, async (req, res) => {
    const familyId = Number(req.params.id);
    const { family_name, phone, notes, members } = req.body || {};

    if (!familyId) {
      return res.status(400).json({ error: 'Família inválida.' });
    }

    if (!family_name || !Array.isArray(members) || members.length === 0) {
      return res.status(400).json({ error: 'Nome da família e membros são obrigatórios.' });
    }

    try {
      const result = await withTransaction(async (client) => {
        await client.query(
          'UPDATE guest_families SET family_name = $1, phone = $2, notes = $3 WHERE id = $4',
          [family_name.trim(), phone?.trim() || null, notes?.trim() || null, familyId]
        );

        await client.query('DELETE FROM family_members WHERE family_id = $1', [familyId]);

        await Promise.all(
          members.map((member) =>
            client.query(
              'INSERT INTO family_members (family_id, name, relationship) VALUES ($1, $2, $3)',
              [familyId, member.name.trim(), member.relationship?.trim() || null]
            )
          )
        );

        const family = await client.query('SELECT * FROM guest_families WHERE id = $1', [familyId]);
        const familyMembers = await client.query(
          'SELECT * FROM family_members WHERE family_id = $1 ORDER BY created_at ASC',
          [familyId]
        );

        return { family: family.rows[0], members: familyMembers.rows };
      });

      return res.json(result);
    } catch (err) {
      console.error('Error:', err);
      return res.status(500).json({ error: 'Erro ao atualizar família.' });
    }
  });

  app.delete('/api/admin/families/:id', authMiddleware, async (req, res) => {
    const familyId = Number(req.params.id);

    if (!familyId) {
      return res.status(400).json({ error: 'Família inválida.' });
    }

    try {
      await withTransaction(async (client) => {
        await client.query('DELETE FROM family_members WHERE family_id = $1', [familyId]);
        await client.query('DELETE FROM guest_families WHERE id = $1', [familyId]);
      });

      return res.json({ ok: true });
    } catch (err) {
      console.error('Error:', err);
      return res.status(500).json({ error: 'Erro ao remover família.' });
    }
  });

  app.get('/api/access/:code', async (req, res) => {
    const code = (req.params.code || '').replace('-', '').trim();

    if (!code || code.length !== 8) {
      return res.status(400).json({ error: 'Código inválido.' });
    }

    const familyResult = await pool.query(
      'SELECT * FROM guest_families WHERE access_code = $1',
      [code]
    );
    const family = familyResult.rows[0];

    if (!family) {
      return res.status(404).json({ error: 'Código não encontrado.' });
    }

    const members = await pool.query(
      'SELECT * FROM family_members WHERE family_id = $1 ORDER BY created_at ASC',
      [family.id]
    );

    return res.json({ family, members: members.rows });
  });

  app.post('/api/confirmations', async (req, res) => {
    const { confirmations } = req.body || {};

    if (!Array.isArray(confirmations) || confirmations.length === 0) {
      return res.status(400).json({ error: 'Confirmações inválidas.' });
    }

    try {
      await withTransaction(async (client) => {
        await Promise.all(
          confirmations.map((item) =>
            client.query(
              `INSERT INTO member_confirmations
                (member_id, attending, dietary_restrictions, message, confirmed_at, updated_at)
               VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
              [
                item.member_id,
                item.attending ? true : false,
                item.dietary_restrictions || null,
                item.message || null,
              ]
            )
          )
        );
      });

      return res.json({ ok: true });
    } catch (err) {
      console.error('Error:', err);
      return res.status(500).json({ error: 'Erro ao salvar confirmações.' });
    }
  });

  const distDir = path.join(__dirname, '../dist');
  if (fs.existsSync(distDir)) {
    app.use(express.static(distDir));
    app.get('*', (req, res) => {
      res.sendFile(path.join(distDir, 'index.html'));
    });
  }

  app.listen(PORT, () => {
    console.log(`API running on http://localhost:${PORT}`);
  });
};

start();
